---
title: "04_Varying_Baseline_Risk"
author: "Arthur M. Albuquerque"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
          code_folding: hide
          toc: yes
          toc_float: yes
---

If you are interested in the code, you can select the "Show all code" option
on the upper-right corner.

```{r setup, include=FALSE}
knitr::opts_chunk$set()
```

```{r include=FALSE}
# Ensures the package "pacman" is installed
if (!require("pacman")) install.packages("pacman")

# p_load() installs (if necessary) and loads the following packages

pacman::p_load(rio, # To import data
               here, # To find file paths within R project
               janitor, # To change column names
               tidyverse, # Data wrangling and plotting
               flextable, # For tables
               patchwork, # To arrange plots
               kableExtra # To make tables
               )
```


```{r}

## Load posterior distributions' samples with logOR, OR and RD

# I uploaded these data objects to OSF since the .RData file is 54MB.
# Here I load all data files directly from OSF without having to download it
# to my/your PC

samples = url("https://osf.io/3qexw/download?version=1")
load(gzcon(samples))


# Load original data extraction table

d1 = import((here("final_analyses", "output", "data", # file path
                                "respiratory-data.csv")),           # file name
                          header = T)
d1 = d1 %>% 
  as_tibble() %>% 
  select(!starts_with("X")) 

# Load corticosteroids raw data

d2 = import(here("final_analyses", "data", # file path
                            "corticosteroids_subgroup_extracted-data.xlsx"))

d2 = clean_names(d2)

```

# Varying the baseline risk

As mentioned in previous documents, the primary analyses with risk difference
are performed under a fixed baseline risk per subgroup. We used the following
formula provided by
[Doi et al.](https://www.jclinepi.com/article/S0895-4356(20)31171-9/fulltext)
to derive the risk difference from odds ratio. Here, $R D$ is risk difference,
$B R$ is baseline risk from the control group (no-exposure) and $O R$ is
odds ratio.

$$R D=\frac{B R * \left(B R-1\right)* \left(O R-1\right)}{B R*O R-B R+1}$$

In the document ["02_Calculating_Posterior_Distribution"](https://github.com/arthur-albuquerque/tocilizumab_reanalysis/tree/master/final_analyses/analyses), we used the risk in RECOVERY's
control group as the BR for each respective subgroup.

In this document, we are going to go further and vary the BR by 20% up and down.
For example, in the "simple oxygen only" subgroup, the fixed BR was 23%. Thus, 
we are going to vary the BR from 3% to 43%. We will apply this logic to all
five subgroups.

We will use the same formula mentioned above. Below, you can check the code
used for the analysis.

```{r}

# Adapted function version to be able to apply it in the code chunk below
RD_fun_mod = function(x) {
  z = ( BR*(BR-1)*(x$OR-1) ) / ( BR*x$OR - BR+1)
  z
}

```

```{r}
##### BE AWARE THESE ARE A LOT OF CALCULATIONS AND IT MIGHT TAKE SOME TIME
# I suppressed this code chunk after I ran it for the first time and
# saved the outputs. Feel free to run it.

# I will first assign the original fixed baseline risk
# Then, I will use this baseline risk as a reference to create a range -20/+20%
# Lastly, I will apply the function above to create a new data frame with
# separate columns for risk differences, one from each of these baseline risk.
# These new columns will be named "RD_'baseline risk used'", for example:
# RD_0.30, RD_0.31... etc


# I asked for help to the R4DS Online Learning Community on Slack
# Thus, who solved the script in this code chunk was ARNAB PANJA (thank you)

# Let's do this cycle of calculations for each of the subgroups

#  ### Use of corticosteroids

#   # Not using
#     
#   original_fixed_BR =  d2 %>% 
#       filter(trial == "RECOVERY",
#              corticosteroids == 0, # Not using
#              outcome == "mortality") %>% 
#         summarise(n = events_control/total_control) %>%
#         pull()
#   
#   # Range from ~20% below and ~20% above the original fixed Baseline Risk (BR)
#   lower_range = round(original_fixed_BR - 0.2, 2)
#   upper_range = round(original_fixed_BR + 0.2,2)
#   
#   # Vector with multiples BRs
#   BR = seq(lower_range, upper_range, 0.01)
#   
#   # Select only the OR column from the original tibble and transform into DF
#   d = samples_posteriors_not_using_death %>% select(OR) %>% as.data.frame()
#   
#   # Run the function (lots of calculations)
#   dBR = plyr::adply(.data = d, 
#               .margins = 1, 
#               .fun = function(x) RD_fun_mod(x)) %>% 
#     setNames(c(colnames(d)[1], paste0("RD_", BR)))
#   
#   # Get the "Underlying_Prior" and "log(OR)" columns back again and bind with d1
#   multiple_baseline_risks_not_using_death = 
#     bind_cols(samples_posteriors_not_using_death[1:2] %>% as.data.frame(),
#               dBR)
#   
#   # Using
#     
#   original_fixed_BR =  d2 %>% 
#       filter(trial == "RECOVERY",
#              corticosteroids == 1, # Using
#              outcome == "mortality") %>% 
#         summarise(n = events_control/total_control) %>%
#         pull()
#   
#   # Range from ~20% below and ~20% above the original fixed Baseline Risk (BR)
#   lower_range = round(original_fixed_BR - 0.2, 2)
#   upper_range = round(original_fixed_BR + 0.2,2)
#   
#   # Vector with multiples BRs
#   BR = seq(lower_range, upper_range, 0.01)
#   
#   # Select only the OR column from the original tibble and transform into DF
#   d = samples_posteriors_using_death %>% select(OR) %>% as.data.frame()
#   
#   # Run the function (lots of calculations)
#   dBR = plyr::adply(.data = d, 
#               .margins = 1, 
#               .fun = function(x) RD_fun_mod(x)) %>% 
#     setNames(c(colnames(d)[1], paste0("RD_", BR)))
#   
#   # Get the "Underlying_Prior" and "log(OR)" columns back again and bind with dBR
#   multiple_baseline_risks_using_death = 
#     bind_cols(samples_posteriors_using_death[1:2] %>% as.data.frame(),
#               dBR)
#   
#   ## Respiratory support
#   
#   # Simple oxygen only
#   
#   original_fixed_BR = d1 %>% 
#     filter(trial == "RECOVERY",
#            oxygen == "simple oxygen",
#            outcome == "mortality") %>% 
#     summarise(n = events_control/total_control) %>%
#     pull()
#   
#   # Range from ~20% below and ~20% above the original fixed Baseline Risk (BR)
#   lower_range = round(original_fixed_BR - 0.2, 2)
#   upper_range = round(original_fixed_BR + 0.2,2)
#   
#   # Vector with multiples BRs
#   BR = seq(lower_range, upper_range, 0.01)
#   
#   # Select only the OR column from the original tibble and transform into DF
#   d = samples_posteriors_simple_death %>% select(OR) %>% as.data.frame()
#   
#   # Run the function (lots of calculations)
#   dBR = plyr::adply(.data = d, 
#               .margins = 1, 
#               .fun = function(x) RD_fun_mod(x)) %>% 
#     setNames(c(colnames(d)[1], paste0("RD_", BR)))
#   
#   # Get the "Underlying_Prior" and "log(OR)" columns back again and bind with dBR
#   multiple_baseline_risks_simple_death = 
#     bind_cols(samples_posteriors_simple_death[1:2] %>% as.data.frame(),
#               dBR)
#   
#   # Non-invasive ventilation
#   
#   original_fixed_BR = d1 %>% 
#     filter(trial == "RECOVERY",
#            oxygen == "non-invasive ventilation",
#            outcome == "mortality") %>% 
#     summarise(n = events_control/total_control) %>%
#     pull()
#   
#   # Range from ~20% below and ~20% above the original fixed Baseline Risk (BR)
#   lower_range = round(original_fixed_BR - 0.2, 2)
#   upper_range = round(original_fixed_BR + 0.2,2)
#   
#   # Vector with multiples BRs
#   BR = seq(lower_range, upper_range, 0.01)
#   
#   # Select only the OR column from the original tibble and transform into DF
#   d = samples_posteriors_noninvasive_death %>% select(OR) %>% as.data.frame()
#   
#   # Run the function (lots of calculations)
#   dBR = plyr::adply(.data = d, 
#               .margins = 1, 
#               .fun = function(x) RD_fun_mod(x)) %>% 
#     setNames(c(colnames(d)[1], paste0("RD_", BR)))
#   
#   # Get the "Underlying_Prior" and "log(OR)" columns back again and bind with dBR
#   multiple_baseline_risks_noninvasive_death = 
#     bind_cols(samples_posteriors_noninvasive_death[1:2] %>% as.data.frame(),
#               dBR)
#   
#   # Invasive mechanical ventilation
#   
#   original_fixed_BR = d1 %>% 
#     filter(trial == "RECOVERY",
#            oxygen == "invasive ventilation",
#            outcome == "mortality") %>% 
#     summarise(n = events_control/total_control) %>%
#     pull()
#   
#   # Range from ~20% below and ~20% above the original fixed Baseline Risk (BR)
#   lower_range = round(original_fixed_BR - 0.2, 2)
#   upper_range = round(original_fixed_BR + 0.2,2)
#   
#   # Vector with multiples BRs
#   BR = seq(lower_range, upper_range, 0.01)
#   
#   # Select only the OR column from the original tibble and transform into DF
#   d = samples_posteriors_invasive_death %>% select(OR) %>% as.data.frame()
#   
#   # Run the function (lots of calculations)
#   dBR = plyr::adply(.data = d, 
#               .margins = 1, 
#               .fun = function(x) RD_fun_mod(x)) %>% 
#     setNames(c(colnames(d)[1], paste0("RD_", BR)))
#   
#   # Get the "Underlying_Prior" and "log(OR)" columns back again and bind with dBR
#   multiple_baseline_risks_invasive_death = 
#     bind_cols(samples_posteriors_invasive_death[1:2] %>% as.data.frame(),
#               dBR)

#  Remove large objects with samples that was loaded in this document and has no
#  use after this code chunk

#  rm(samples_posteriors_not_using_death,
#     samples_posteriors_using_death,
#     samples_posteriors_simple_death,
#     samples_posteriors_noninvasive_death,
#     samples_posteriors_invasive_death)
```

```{r}
# Code to save the output from above in different files since
# they are huge data frames

# saveRDS(multiple_baseline_risks_not_using_death,
#         file = here("final_analyses", "output", "data", "analyses", # file path
#                     "multiple_baseline_risks_not_using_death.rds"))
# saveRDS(multiple_baseline_risks_using_death,
#         file = here("final_analyses", "output", "data", "analyses", # file path
#                     "multiple_baseline_risks_using_death.rds"))
# saveRDS(multiple_baseline_risks_simple_death,
#         file = here("final_analyses", "output", "data", "analyses", # file path
#                     "multiple_baseline_risks_simple_death.rds"))
# saveRDS(multiple_baseline_risks_noninvasive_death,
#         file = here("final_analyses", "output", "data", "analyses", # file path
#                     "multiple_baseline_risks_noninvasive_death.rds"))
# saveRDS(multiple_baseline_risks_invasive_death,
#         file = here("final_analyses", "output", "data", "analyses", # file path
#                     "multiple_baseline_risks_invasive_death.rds"))
```

```{r}
## I uploaded all the .rds files above into OSF
## here is the link for one of them https://osf.io/7t4hm/

## Run this code chunk if you have downloaded the files from OSF into your PC


# Load the files from the code chunks above

multiple_baseline_risks_not_using_death = 
  readRDS(file = here("final_analyses", "output", "data", "analyses", # file path
                    "multiple_baseline_risks_not_using_death.rds"))

multiple_baseline_risks_using_death = 
readRDS(file = here("final_analyses", "output", "data", "analyses", # file path
                    "multiple_baseline_risks_using_death.rds"))

multiple_baseline_risks_simple_death = 
  readRDS(file = here("final_analyses", "output", "data", "analyses", # file path
                    "multiple_baseline_risks_simple_death.rds"))

multiple_baseline_risks_noninvasive_death = 
  readRDS(file = here("final_analyses", "output", "data", "analyses", # file path
                    "multiple_baseline_risks_noninvasive_death.rds"))

multiple_baseline_risks_invasive_death = 
  readRDS(file = here("final_analyses", "output", "data", "analyses", # file path
                    "multiple_baseline_risks_invasive_death.rds"))
```

```{r}
# In case you did not download the files from OSF, run this code chunk 
# Here, you can load the .rds files directly from OSF, without having to
# download it

# I adapted the code from https://osf.io/73thx/ to be able to load files in
# OSF into RStudio without having to download it

# This should take some time, since each file has ~165MB
# If it the loading "times out", try it again, it should work
# If it doesn't work, then download the files from OSF and run the code chunk above

## Use of corticosteroids

# Not using

#not_using = url("https://osf.io/fwj2y/download?version=1")

#multiple_baseline_risks_not_using_death = readRDS(gzcon(not_using))
```

```{r}
# Using

#using = url("https://osf.io/bn6tf/download?version=1")

#multiple_baseline_risks_using_death = readRDS(gzcon(using))
```

```{r}
## Respiratory support

# Simple oxygen only

#simple = url("https://osf.io/cqea9/download?version=1")

#multiple_baseline_risks_simple_death = readRDS(gzcon(simple))

```

```{r}
# Non-invasive ventilation

#noninvasive = url("https://osf.io/bhfwr/download?version=1")

#multiple_baseline_risks_noninvasive_death = readRDS(gzcon(noninvasive))
```

```{r}
# Invasive mechanical ventilation

#invasive = url("https://osf.io/7t4hm/download?version=1")

#multiple_baseline_risks_invasive_death = readRDS(gzcon(invasive))
```


Now, we are going to calculate the probability of benefit for each baseline risk
using different cutoffs for risk difference, such as greater than $0$, $1$, $2$,
$5$ and $10$%. The **idea** for the following analysis was heavily influenced by 
[Goligher et al. 2018](https://jamanetwork.com/journals/jama/article-abstract/2709620).
Although they do not show these figures in the manuscript, they made their
[code available elsewhere](https://thebru.ca/code-data).



```{r}
# Function to generate tibble with probability of benefit vs. baseline risk

probability_by_baseline_risk = function(data, # "multiple_baseline_risks..." data object
                                         type, # Underlying Prior (within quotes)
                                         all_probs # Tibble output name
) {
  prob1 = data %>%
    # Filter by underlying prior
    filter(`Underlying_Prior` == type) %>%
    # Remove Underlying Prior, log(OR) and OR columns
    select(-(`Underlying_Prior`:OR)) %>%
    # To calculate proportion of values greater than the assigned risk difference
    # This is analogous to the (posterior) probability of benefit, since
    # RD > 0 equals benefit
    mutate(across(everything(), ~ sum(. > 0) / n())) %>%
    # Select just the first row, since all rows are now equal to each other
    slice(1) %>%
    # Transform into long format
    pivot_longer(
      cols = everything(),
      names_to = "Baseline_risk", values_to = "Pr_0"
    ) %>%
    # Isolate the Baseline risk from the string
    separate(Baseline_risk,
      sep = "_",
      c(NA, "Baseline_risk")
    ) %>%
    # Transform this column into "double" for ggplot() later
    mutate(Baseline_risk = as.numeric(Baseline_risk))

  # Now repeat the process several times, just changing the cutoff
  prob2 = data %>%
    filter(`Underlying_Prior` == type) %>%
    select(-(`Underlying_Prior`:OR)) %>%
    mutate(across(everything(), ~ sum(. > 0.01) / n())) %>%
    slice(1) %>%
    pivot_longer(
      cols = everything(),
      names_to = "Baseline_risk", values_to = "Pr_0.01"
    ) %>%
    separate(Baseline_risk,
      sep = "_",
      c(NA, "Baseline_risk")
    ) %>%
    mutate(Baseline_risk = as.numeric(Baseline_risk))

  prob3 = data %>%
    filter(`Underlying_Prior` == type) %>%
    select(-(`Underlying_Prior`:OR)) %>%
    mutate(across(everything(), ~ sum(. > 0.02) / n())) %>%
    slice(1) %>%
    pivot_longer(
      cols = everything(),
      names_to = "Baseline_risk", values_to = "Pr_0.02"
    ) %>%
    separate(Baseline_risk,
      sep = "_",
      c(NA, "Baseline_risk")
    ) %>%
    mutate(Baseline_risk = as.numeric(Baseline_risk))

  prob4 = data %>%
    filter(`Underlying_Prior` == type) %>%
    select(-(`Underlying_Prior`:OR)) %>%
    mutate(across(everything(), ~ sum(. > 0.05) / n())) %>%
    slice(1) %>%
    pivot_longer(
      cols = everything(),
      names_to = "Baseline_risk", values_to = "Pr_0.05"
    ) %>%
    separate(Baseline_risk,
      sep = "_",
      c(NA, "Baseline_risk")
    ) %>%
    mutate(Baseline_risk = as.numeric(Baseline_risk))

  prob5 = data %>%
    filter(`Underlying_Prior` == type) %>%
    select(-(`Underlying_Prior`:OR)) %>%
    mutate(across(everything(), ~ sum(. > 0.1) / n())) %>%
    slice(1) %>%
    pivot_longer(
      cols = everything(),
      names_to = "Baseline_risk", values_to = "Pr_0.1"
    ) %>%
    separate(Baseline_risk,
      sep = "_",
      c(NA, "Baseline_risk")
    ) %>%
    mutate(Baseline_risk = as.numeric(Baseline_risk))

  # Join all data frames just adding the columns "Pr_..."
  all_probs = left_join(prob1, prob2)

  all_probs = left_join(all_probs, prob3)

  all_probs = left_join(all_probs, prob4)

  all_probs = left_join(all_probs, prob5)
}
```

```{r message=FALSE, warning=FALSE}
# Generate tibbles per subgroup

## Use of corticosteroids

# Not using

benefit_not_using_death =
  probability_by_baseline_risk(
  multiple_baseline_risks_not_using_death, # data object
  "Evidence-based", # Underlying Prior (within quotes)
  benefit_not_using_death) # Tibble output name

# Using

benefit_using_death =
  probability_by_baseline_risk(
  multiple_baseline_risks_using_death, # data object
  "Evidence-based", # Underlying Prior (within quotes)
  benefit_using_death) # Tibble output name

## Respiratory support

# Simple oxygen only

benefit_simple_death =
  probability_by_baseline_risk(
  multiple_baseline_risks_simple_death, # data object
  "Evidence-based", # Underlying Prior (within quotes)
  benefit_simple_death) # Tibble output name

# Non-invasive ventilation

benefit_noninvasive_death =
  probability_by_baseline_risk(
  multiple_baseline_risks_noninvasive_death, # data object
  "Evidence-based", # Underlying Prior (within quotes)
  benefit_noninvasive_death) # Tibble output name

# Invasive mechanical ventilation

benefit_invasive_death =
  probability_by_baseline_risk(
  multiple_baseline_risks_invasive_death, # data object
  "Evidence-based", # Underlying Prior (within quotes)
  benefit_invasive_death) # Tibble output name
```

Here is an example of the first six rows of one of these tibbles:

```{r}
benefit_invasive_death %>% head() %>% flextable() 
```

## Plotting

Finally, let's plot these posterior probabilities of benefit for each subgroup,
while varying the baseline risk. Black vertical dashed lines represent the 
fixed baseline risk used in the primary analyses for each subgroup
(["02_Calculating_Posterior_Distribution" file](https://github.com/arthur-albuquerque/tocilizumab_reanalysis/tree/master/final_analyses/analyses)).

```{r}
# Plot!

p1 = benefit_not_using_death %>% 
  # Make it tidy for ggplot
  pivot_longer(
    cols = Pr_0:last_col(),
    names_to = "RD", values_to = "Probabilities"
  ) %>%
  ggplot(aes(x = 100*Baseline_risk, y = 100*Probabilities))+
  geom_line(aes(color = RD), size = 1.15) +
  # Dashed line corresponding to the fixed baseline risk used in the primary
  # analyses
  geom_vline(xintercept = benefit_not_using_death[[21,1]]*100, linetype = 2) +
  scale_x_continuous("Baseline Risk (%)",
                     seq((benefit_not_using_death[[1,1]]*100),
                         (benefit_not_using_death[[41,1]]*100),
                         5)) +
  scale_y_continuous("Posterior Probability of Benefit (%)\n",
                     seq(0, 100, 10))+
  coord_cartesian(y = c(0, 100)) +
  labs(title = "Not using") +
  
  theme(legend.position = 'none',
        plot.title.position = 'plot',
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 11),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(size = 10),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        panel.background = element_blank(),
        panel.grid.major.x = element_line(color = "gray80", size = 0.3),
        panel.grid.major.y = element_line(color = "gray80", size = 0.3))
  

p2 = benefit_using_death %>%
  rename("\u2265 0%" = Pr_0,
         "\u2265 1%" = Pr_0.01,
         "\u2265 2%" = Pr_0.02,
         "\u2265 5%" = Pr_0.05,
         "\u2265 10%" = Pr_0.1) %>% 
  # Make it tidy for ggplot
  pivot_longer(
    cols = "\u2265 0%":last_col(),
    names_to = "RD", values_to = "Probabilities"
  ) %>%
  mutate(RD = factor(RD,
      levels = c(
        "\u2265 0%",
        "\u2265 1%",
        "\u2265 2%",
        "\u2265 5%",
        "\u2265 10%"
        )
    )) %>% 
  ggplot(aes(x = 100*Baseline_risk, y = 100*Probabilities))+
  geom_line(aes(color = RD), size = 1.15)+
  # Dashed line corresponding to the fixed baseline risk used in the primary
  # analyses
  geom_vline(xintercept = benefit_using_death[[21,1]]*100, linetype = 2) +
  scale_x_continuous("Baseline Risk (%)", 
                     seq((benefit_using_death[[1,1]]*100),
                         (benefit_using_death[[41,1]]*100),
                         5)) +
  scale_y_continuous(" ",
                     seq(0, 100, 10))+
  coord_cartesian(y = c(0, 100)) +
  labs(title = "Using",
       y = " ") +
  
  theme(legend.key = element_blank(),
        plot.title.position = 'plot',
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 13.5),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(size = 10),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        panel.background = element_blank(),
        panel.grid.major.x = element_line(color = "gray80", size = 0.3),
        panel.grid.major.y = element_line(color = "gray80", size = 0.3))

p3 = benefit_simple_death %>% 
  # Make it tidy for ggplot
  pivot_longer(
    cols = Pr_0:last_col(),
    names_to = "RD", values_to = "Probabilities"
  ) %>%
  ggplot(aes(x = 100*Baseline_risk, y = 100*Probabilities))+
  geom_line(aes(color = RD), size = 1.15) +
  # Dashed line corresponding to the fixed baseline risk used in the primary
  # analyses
  geom_vline(xintercept = benefit_simple_death[[21,1]]*100, linetype = 2) +
  scale_x_continuous("Baseline Risk (%)",
                     seq((benefit_simple_death[[1,1]]*100),
                         (benefit_simple_death[[41,1]]*100),
                         8)) +
  scale_y_continuous("Posterior Probability of Benefit (%)\n",
                     seq(0, 100, 10))+
  theme(legend.position = 'none') +
  labs(title = "Simple oxygen") +
  
  theme(legend.position = 'none',
        plot.title.position = 'plot',
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 11),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(size = 10),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        panel.background = element_blank(),
        panel.grid.major.x = element_line(color = "gray80", size = 0.3),
        panel.grid.major.y = element_line(color = "gray80", size = 0.3))

p4 = benefit_noninvasive_death %>% 
  # Make it tidy for ggplot
  pivot_longer(
    cols = Pr_0:last_col(),
    names_to = "RD", values_to = "Probabilities"
  ) %>%
  ggplot(aes(x = 100*Baseline_risk, y = 100*Probabilities))+
  geom_line(aes(color = RD), size = 1.15) +
  # Dashed line corresponding to the fixed baseline risk used in the primary
  # analyses
  geom_vline(xintercept = benefit_noninvasive_death[[21,1]]*100, linetype = 2) +
  scale_x_continuous("Baseline Risk (%)",
                     seq((benefit_noninvasive_death[[1,1]]*100),
                         (benefit_noninvasive_death[[41,1]]*100),
                         8)) +
  scale_y_continuous(" ",
                     seq(0, 100, 10))+
  theme(legend.position = 'none') +
  labs(title = "Non-invasive") +
  
  theme(legend.position = 'none',
        plot.title.position = 'plot',
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 13.5),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(size = 10),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        panel.background = element_blank(),
        panel.grid.major.x = element_line(color = "gray80", size = 0.3),
        panel.grid.major.y = element_line(color = "gray80", size = 0.3))

p5 = benefit_invasive_death %>% 
  rename("\u2265 0%" = Pr_0,
         "\u2265 1%" = Pr_0.01,
         "\u2265 2%" = Pr_0.02,
         "\u2265 5%" = Pr_0.05,
         "\u2265 10%" = Pr_0.1) %>%
  # Make it tidy for ggplot
  pivot_longer(
    cols = "\u2265 0%":last_col(),
    names_to = "RD", values_to = "Probabilities"
  ) %>%
  mutate(RD = factor(RD,
      levels = c(
        "\u2265 0%",
        "\u2265 1%",
        "\u2265 2%",
        "\u2265 5%",
        "\u2265 10%"
        )
    )) %>% 
  ggplot(aes(x = 100*Baseline_risk, y = 100*Probabilities))+
  geom_line(aes(color = RD), size = 1.15) +
  # Dashed line corresponding to the fixed baseline risk used in the primary
  # analyses
  geom_vline(xintercept = benefit_invasive_death[[21,1]]*100, linetype = 2) +
  scale_x_continuous("Baseline Risk (%)",
                     seq((benefit_invasive_death[[1,1]]*100),
                         (benefit_invasive_death[[41,1]]*100),
                         8)) +
  scale_y_continuous(" ",
                     seq(0, 100, 10))+
  labs(title = "Invasive") +
  coord_cartesian(y = c(0, 100)) +
  
  theme(legend.key = element_blank(),
        plot.title.position = 'plot',
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 13.5),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(size = 10),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        panel.background = element_blank(),
        panel.grid.major.x = element_line(color = "gray80", size = 0.3),
        panel.grid.major.y = element_line(color = "gray80", size = 0.3))
```

```{r, fig.align='center', fig.height=5, fig.width=8}
p1 + p2 + plot_annotation(title = "Use of corticosteroids subgroups\n")
```

```{r, fig.align='center', fig.height=5, fig.width=8, fig.cap="RD: Risk Difference"}
p3 + p4 + p5 + plot_annotation(title = "Respiratory support subgroups\n")
```

## Tables

Next, we are going to put in tables what are the minimum + maximum "Posterior
Probability of Benefit" and their corresponding "Baseline Risk" for each RD
cutoff.

```{r}
# Create function to make tables

values = tibble(Values = c("Min", "Max"))
multiply100 = function(x){x*100}

tables_fun = function(data){ # Data object
  
t1 = data %>%
  # make it tidy to use filter()
  pivot_longer(
    cols = Pr_0:last_col(),
    names_to = "Cutoff", values_to = "Pr of Benefit"
  ) %>% 
  # filter by Pr of Benefit >= 0%
  filter(Cutoff == "Pr_0") %>%
  # Multiply by 100
  mutate(Baseline_risk = Baseline_risk*100,
         `Pr of Benefit` = `Pr of Benefit`*100) %>% 
  # round the probability of benefit
  mutate(`Pr of Benefit` = round(`Pr of Benefit`, 2)) %>% 
  # select rows with minimum and maximum Pr of Benefit value
  slice(which.min(`Pr of Benefit`),
        which.max(`Pr of Benefit`)) %>%
  # Add new colum with "Min" and "Max"
  bind_cols(values) %>% 
  # Re-arrange the order of columns
  select(Cutoff, Values, Baseline_risk, "Pr of Benefit") %>%
  # Reverse back to wide format
  pivot_wider(names_from = "Values", values_from = Baseline_risk:`Pr of Benefit`) %>% 
  # Rename columns
  rename("min(Baseline Risk)" = Baseline_risk_Min,
         "max(Baseline Risk)" = Baseline_risk_Max,
         "min(Pr of Benefit)" = `Pr of Benefit_Min`,
         "max(Pr of Benefit)" = `Pr of Benefit_Max`) %>% 
  # Reorder
  select(Cutoff,
         "min(Pr of Benefit)", "min(Baseline Risk)",
         "max(Pr of Benefit)", "max(Baseline Risk)")

t2 = data %>%
  # make it tidy to use filter()
  pivot_longer(
    cols = Pr_0:last_col(),
    names_to = "Cutoff", values_to = "Pr of Benefit"
  ) %>% 
  # filter by Pr of Benefit >= 0%
  filter(Cutoff == "Pr_0.01") %>% 
  # Multiply by 100
  mutate(Baseline_risk = Baseline_risk*100,
         `Pr of Benefit` = `Pr of Benefit`*100) %>% 
  # round the probability of benefit
  mutate(`Pr of Benefit` = round(`Pr of Benefit`, 2)) %>% 
  # select rows with minimum and maximum Pr of Benefit value
  slice(which.min(`Pr of Benefit`),
        which.max(`Pr of Benefit`)) %>%
  # Add new colum with "Min" and "Max"
  bind_cols(values) %>% 
  # Re-arrange the order of columns
  select(Cutoff, Values, Baseline_risk, "Pr of Benefit") %>%
  # Reverse back to wide format
  pivot_wider(names_from = "Values", values_from = Baseline_risk:`Pr of Benefit`) %>% 
  # Rename columns
  rename("min(Baseline Risk)" = Baseline_risk_Min,
         "max(Baseline Risk)" = Baseline_risk_Max,
         "min(Pr of Benefit)" = `Pr of Benefit_Min`,
         "max(Pr of Benefit)" = `Pr of Benefit_Max`) %>% 
  # Reorder
  select(Cutoff,
         "min(Pr of Benefit)", "min(Baseline Risk)",
         "max(Pr of Benefit)", "max(Baseline Risk)")

t3 = data %>%
  # make it tidy to use filter()
  pivot_longer(
    cols = Pr_0:last_col(),
    names_to = "Cutoff", values_to = "Pr of Benefit"
  ) %>% 
  # filter by Pr of Benefit >= 0%
  filter(Cutoff == "Pr_0.02") %>% 
  # Multiply by 100
  mutate(Baseline_risk = Baseline_risk*100,
         `Pr of Benefit` = `Pr of Benefit`*100) %>% 
  # round the probability of benefit
  mutate(`Pr of Benefit` = round(`Pr of Benefit`, 2)) %>% 
  # select rows with minimum and maximum Pr of Benefit value
  slice(which.min(`Pr of Benefit`),
        which.max(`Pr of Benefit`)) %>%
  # Add new colum with "Min" and "Max"
  bind_cols(values) %>% 
  # Re-arrange the order of columns
  select(Cutoff, Values, Baseline_risk, "Pr of Benefit") %>%
  # Reverse back to wide format
  pivot_wider(names_from = "Values", values_from = Baseline_risk:`Pr of Benefit`) %>% 
  # Rename columns
  rename("min(Baseline Risk)" = Baseline_risk_Min,
         "max(Baseline Risk)" = Baseline_risk_Max,
         "min(Pr of Benefit)" = `Pr of Benefit_Min`,
         "max(Pr of Benefit)" = `Pr of Benefit_Max`) %>% 
  #Reorder
  select(Cutoff,
         "min(Pr of Benefit)", "min(Baseline Risk)",
         "max(Pr of Benefit)", "max(Baseline Risk)")

t4 = data %>%
  # make it tidy to use filter()
  pivot_longer(
    cols = Pr_0:last_col(),
    names_to = "Cutoff", values_to = "Pr of Benefit"
  ) %>% 
  # filter by Pr of Benefit >= 0%
  filter(Cutoff == "Pr_0.05") %>% 
  # Multiply by 100
  mutate(Baseline_risk = Baseline_risk*100,
         `Pr of Benefit` = `Pr of Benefit`*100) %>% 
  # round the probability of benefit
  mutate(`Pr of Benefit` = round(`Pr of Benefit`, 2)) %>% 
  # select rows with minimum and maximum Pr of Benefit value
  slice(which.min(`Pr of Benefit`),
        which.max(`Pr of Benefit`)) %>%
  # Add new colum with "Min" and "Max"
  bind_cols(values) %>% 
  # Re-arrange the order of columns
  select(Cutoff, Values, Baseline_risk, "Pr of Benefit") %>%
  # Reverse back to wide format
  pivot_wider(names_from = "Values", values_from = Baseline_risk:`Pr of Benefit`) %>% 
  # Rename columns
  rename("min(Baseline Risk)" = Baseline_risk_Min,
         "max(Baseline Risk)" = Baseline_risk_Max,
         "min(Pr of Benefit)" = `Pr of Benefit_Min`,
         "max(Pr of Benefit)" = `Pr of Benefit_Max`) %>% 
  # Reorder
  select(Cutoff,
         "min(Pr of Benefit)", "min(Baseline Risk)",
         "max(Pr of Benefit)", "max(Baseline Risk)")

t5 = data %>%
  # make it tidy to use filter()
  pivot_longer(
    cols = Pr_0:last_col(),
    names_to = "Cutoff", values_to = "Pr of Benefit"
  ) %>% 
  # filter by Pr of Benefit >= 0%
  filter(Cutoff == "Pr_0.1") %>% 
  # Multiply by 100
  mutate(Baseline_risk = Baseline_risk*100,
         `Pr of Benefit` = `Pr of Benefit`*100) %>% 
  # round the probability of benefit
  mutate(`Pr of Benefit` = round(`Pr of Benefit`, 2)) %>% 
  # select rows with minimum and maximum Pr of Benefit value
  slice(which.min(`Pr of Benefit`),
        which.max(`Pr of Benefit`)) %>%
  # Add new colum with "Min" and "Max"
  bind_cols(values) %>% 
  # Re-arrange the order of columns
  select(Cutoff, Values, Baseline_risk, "Pr of Benefit") %>%
  # Reverse back to wide format
  pivot_wider(names_from = "Values", values_from = Baseline_risk:`Pr of Benefit`) %>% 
  # Rename columns
  rename("min(Baseline Risk)" = Baseline_risk_Min,
         "max(Baseline Risk)" = Baseline_risk_Max,
         "min(Pr of Benefit)" = `Pr of Benefit_Min`,
         "max(Pr of Benefit)" = `Pr of Benefit_Max`) %>% 
  # Reorder
  select(Cutoff,
         "min(Pr of Benefit)", "min(Baseline Risk)",
         "max(Pr of Benefit)", "max(Baseline Risk)")

tt = bind_rows(t1,t2)
tt = bind_rows(tt,t3)
tt = bind_rows(tt,t4)
tt = bind_rows(tt,t5) %>% 
  kbl(booktabs = T, align = 'c') %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)

return(tt)
}
```

### Not using corticosteroids

```{r}
tables_fun(benefit_not_using_death)
```

### Using corticosteroids

```{r}
tables_fun(benefit_using_death)
```

### Simple oxygen only

```{r}
tables_fun(benefit_simple_death)
```

### Non-invasive ventilation

```{r}
tables_fun(benefit_noninvasive_death)
```

### Invasive mechanical ventilation

```{r}
tables_fun(benefit_invasive_death)
```


# Verification

The curvature of these lines are interesting. Let's verify if these calculations
are correct.

As mentioned above, we used the formula provided by
[Doi et al.](https://www.jclinepi.com/article/S0895-4356(20)31171-9/fulltext) to
derive risk differences. In their article, there are two figures (Fig. 5C 
+ Fig. 6C) in which they display the relationship between baseline risk and
risk difference:

```{r echo=FALSE, fig.align = 'center', fig.cap="Adapted figures from Doi et al. 2020. 'RDOR' means that the risk differences were derived using odds ratio, such as in this project."}

knitr::include_graphics(rep(here("final_analyses", "analyses", "doi_et_al_figures.png")))
```

<br>

Let's plot the relationship between the (mean) risk difference and baseline risk
using our data. We only have 41 values (fixed BR from RECOVERY +- 20%) in each
subgroup, thus we will not be able to fully appreciate the curvature, but
hopefully it should be enough.

```{r}
# Create a function since we are doing this several times

plot_br_rd = function(data, # Data object
                      text, # Title (within quotes)
                      ylim # Y axis range
                      ){
  data %>%
    # Filter by underlying prior
    filter(`Underlying_Prior` == "Evidence-based") %>%
    # Remove Underlying Prior, log(OR) and OR columns
    select(-(`Underlying_Prior`:OR)) %>%
    # To calculate the mean risk difference
    mutate(across(everything(), ~ mean(.))) %>%
    # Select just the first row, since all rows are now equal to each other
    slice(1) %>%
    # Transform into long format
    pivot_longer(
      cols = everything(),
      names_to = "Baseline_risk", values_to = "Risk_difference"
    ) %>%
    # Isolate the Baseline risk from the string
    separate(Baseline_risk,
      sep = "_",
      c(NA, "Baseline_risk")
    ) %>%
    # Transform this column into "double" for ggplot() later
    mutate(Baseline_risk = as.numeric(Baseline_risk)) %>% 
  ggplot(aes(x = Baseline_risk, y =  Risk_difference)) +
  geom_line() +
  coord_cartesian(x = c(0, 0.75),
                  y = ylim) +
    labs(title = text,
         x = "Baseline risk",
         y = "Risk difference")
  
}
```

```{r}
p1 = plot_br_rd(multiple_baseline_risks_not_using_death,
                "Not using",
                c(-0.05, 0.05))
p2 = plot_br_rd(multiple_baseline_risks_using_death,
                "Using",
                c(0, 0.075))

p3 = plot_br_rd(multiple_baseline_risks_simple_death,
                "Simple oxygen",
                c(0, 0.06))
p4 = plot_br_rd(multiple_baseline_risks_noninvasive_death,
                "Non-invasive",
                c(0, 0.06))
p5 = plot_br_rd(multiple_baseline_risks_invasive_death,
                "Invasive",
                c(0, 0.03))
```

```{r, fig.align='center', fig.height=2, fig.width=6}
(p1 + p2 + plot_annotation(title = "Use of corticosteroids"))
```

```{r, fig.align='center', fig.height=2, fig.width=6}
(p3 + p4 + p5 + plot_annotation(title = "Respiratory support"))
```

<br><br>

As displayed above, our estimates for the risk difference derived from odds
ratio do have similar properties as in Doi et al. 2020.

The curvilinear relationship between BR and RD explains the phenomenon seen
in the "Posterior Probability of Benefit" figures. 
